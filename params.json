{"name":"function2","tagline":"Improved alternative to std::function which supports move only types","body":"\r\n# C++11 Function 2 - fu2::\r\n\r\n[![Build Status](https://travis-ci.org/Naios/function2.svg?branch=master)](https://travis-ci.org/Naios/function2)\r\n\r\nProvides two improved implementations of `std::function`:\r\n\r\n- **copyable** `fu2::function`\r\n- **move-only** `fu2::unique_function`\r\n\r\nwhich are:\r\n\r\n- **const**, **volatile** and **reference** correct (qualifiers are part of the `operator()` signature).\r\n- **convertible** to and from `std::function`.\r\n- **adaptable** through `fu2::function_base` (internal capacity, copyable).\r\n- **covered** by unit tests and continuous integration.\r\n- **header only**, just copy and include `function.hpp` in your project.\r\n\r\n\r\n## Table of Contents\r\n* **[Documentation](#documentation)**\r\n  * **[How to use](#how-to-use)**\r\n  * **[Constructing a function](#constructing-a-function)**\r\n  * **[Non copyable unique functions](#non-copyable-unique-functions)**\r\n  * **[Converbility of functions](#converbility-of-functions)**\r\n  * **[Adapt function2](#adapt-function2)**\r\n* **[Performance and optimization](#performance-and-optimization)**\r\n  * **[Small functor optimization](#small-functor-optimization)**\r\n  * **[Compiler optimization](#compiler-optimization)**\r\n  * **[std::function vs fu2::function](#stdfunction-vs-fu2function)**\r\n* **[Coverage and runtime checks](#coverage-and-runtime-checks)**\r\n* **[Compatibility](#compatibility)**\r\n* **[License](#licence)**\r\n* **[Similar implementations](#similar-implementations)**\r\n\r\n## Documentation\r\n\r\n### How to use\r\n\r\nFunction2 is implemented in one header only file `function.hpp`, no compilation is required.\r\nJust drop and include `function.hpp` to start!\r\n\r\nUse `fu2::function` as a wrapper for copyable function wrappers and `fu2::unique_function` for move only types.\r\nIn most cases is `std::function` and `fu2::function` compatible, see [the chapter converbility of functions](#converbility-of-functions) for details.\r\n\r\nA function wrapper is declared as followed:\r\n```c++\r\nfu2::function<void(int, float) const>\r\n// Return type ~^   ^     ^     ^\r\n// Arguments ~~~~~~~|~~~~~|     ^\r\n// Qualifier ~~~~~~~~~~~~~~~~~~~|\r\n```\r\n\r\n#### Return type\r\nThe return type of the function to wrap.\r\n\r\n#### Arguments\r\nThe argument types of the function to wrap.\r\nAny argument types are allowed.\r\n\r\n#### Qualifiers\r\n\r\nThere are several qualifiers allowed:\r\n\r\n- **no qualifier** provides `ReturnType operator() (Args...)`\r\n  - Can be assigned from const and no const objects (*mutable lambdas* for example).\r\n- **const** provides `ReturnType operator() (Args...) const`\r\n  - Requires that the assigned functor is const callable (won't work with *mutable lambdas*),\r\n- **volatile** provides `ReturnType operator() (Args...) volatile`\r\n  - Can only be assigned from volatile qualified functors.\r\n- **const volatile** provides `ReturnType operator() (Args...) const volatile`\r\n  - Same as const and volatile together.\r\n- Also there is support for **r-value functions** `ReturnType operator() (Args...) &&`\r\n  - one-shot functions which are invalidated after the first call.\r\n\r\n### Constructing a function\r\n\r\n`fu2::function` and `fu2::unique_function` (non copyable) are easy to use:\r\n\r\n```c++\r\nfu2::function<void() const> fun = []\r\n{\r\n\t// ...\r\n};\r\n\r\n// fun provides void operator()() const now\r\nfun();\r\n```\r\n\r\n### Non copyable unique functions\r\n\r\n`fu2::unique_function` also works with non copyable functors/ lambdas.\r\n\r\n```c++\r\nfu2::unique_function<bool() const> fun = [ptr = std::make_unique<bool>(true)]\r\n{\r\n    return *ptr;\r\n};\r\n\r\n// unique functions are move only\r\nfu2::unique_function<bool() const> otherfun = std::move(fun):\r\n\r\notherfun();\r\n```\r\n\r\n### Converbility of functions\r\n\r\n`fu2::function`, `fu2::unique_function` and `std::function` are convertible to each other when:\r\n\r\n- The return type and parameter type match.\r\n- The functions are both volatile or not.\r\n- The functions are const correct:\r\n  - `noconst = const`\r\n  - `const = const`\r\n  - `noconst = noconst`\r\n- The functions are copyable correct when:\r\n  - `unique = unique`\r\n  - `unique = copyable`\r\n  - `copyable = copyable`\r\n- The functions are reference correct when:\r\n  - `lvalue = lvalue`\r\n  - `lvalue = rvalue`\r\n  - `rvalue = rvalue`\r\n\r\n| Cobvertible from \\ to | fu2::function | fu2::unique_function | std::function |\r\n|-----------------------|---------------|----------------------|---------------|\r\n| fu2::function         | Yes           | Yes                  | Yes           |\r\n| fu2::unique_function  | No            | Yes                  | No            |\r\n| std::function         | Yes           | Yes                  | Yes           |\r\n\r\n```c++\r\nfu2::function<void()> fun = []{};\r\n// OK\r\nstd::function<void()> std_fun = fun;\r\n// OK\r\nfu2::unique_function<void()> un_fun = fun;\r\n\r\n// Error (non copyable -> copyable)\r\nfun = un_fun;\r\n// Error (non copyable -> copyable)\r\nfun = un_fun;\r\n\r\n```\r\n\r\n### Adapt function2\r\n\r\nfunction2 is adaptable through `fu2::function_base` which allows you to set:\r\n\r\n- **Signature:** defines the signature of the function.\r\n- **Capacity:** defines the internal capacity used for [sfo optimization](#small-functor-optimization).\r\n- **Copyable:** defines if the function is copyable or not.\r\n\r\nThe following code defines a function with a variadic signature which is copyable and sfo optimization is disabled:\r\n\r\n```c++\r\ntemplate<typename Signature>\r\nusing my_function = fu2::function_base<Signature, 0UL, true>;\r\n```\r\n\r\nThe following code defines a non copyable function which just takes 1 argument, and has a huge capacity for internal sfo optimization.\r\nAlso it must be called as r-value.\r\n\r\n```c++\r\ntemplate<typename Arg>\r\nusing my_consumer = fu2::function_base<void(Arg)&&, 100UL, false>;\r\n\r\n// Example\r\nmy_consumer<int, float> consumer = [](int, float) { }\r\nstd::move(consumer)(44, 1.7363f);\r\n```\r\n\r\n## Performance and optimization\r\n\r\n### Small functor optimization\r\n\r\nFunction 2 uses small functor optimization like the most common std::function implementations which means it allocates a small internal capacity to evade heap allocation for small functors.\r\n\r\nSmart heap allocation moves the inplace allocated functor automatically to the heap to speed up moving between objects.\r\n\r\nIt's possible to disable small functor optimization through setting the capacity to 0.\r\n\r\n### Compiler optimization\r\n\r\nUnique functions are heavily optimized by compilers see below:\r\n\r\n```c++\r\nint main(int argc, char**)\r\n{\r\n    fu2::unique_function<int()> fun([=]\r\n    {\r\n        return argc + 10;\r\n    );\r\n    return fun() + fun();\r\n}\r\n```\r\n\r\n[Clang 3.4+ with -O3 compiles it into](https://goo.gl/F7saQy):\r\n\r\n```asm\r\nmain: # @main\r\n    lea\teax, [rdi + rdi + 20]\r\n    ret\r\n```\r\n\r\n(`std::function` [compiles into ~70 instructions](https://goo.gl/GO4G4b)).\r\n\r\n### std::function vs fu2::function\r\n\r\n```\r\nBenchmark: Construct and copy function wrapper\r\n    std::function:         172535130ns\r\n    fu2::(unique)function: 112452593ns       +53%\r\n\r\nBenchmark: Move function wrapper around\r\n    std::function:         313446044ns\r\n    fu2::(unique)function: 110743394ns       +183%\r\n\r\nBenchmark: Invoke function wrapper\r\n    std::function:         38555121ns\r\n    fu2::(unique)function: 28355481ns        +35%\r\n```\r\n\r\n## Coverage and runtime checks\r\n\r\nFunction2 is checked with unit tests and was tested with valgrind for memory leaks:\r\n\r\n```\r\n===============================================================================\r\nAll tests passed (73 assertions in 7 test cases)\r\n\r\n==15215== LEAK SUMMARY:\r\n==15215==    definitely lost: 0 bytes in 0 blocks\r\n==15215==    indirectly lost: 0 bytes in 0 blocks\r\n==15215==      possibly lost: 0 bytes in 0 blocks\r\n==15215==    still reachable: 72,704 bytes in 1 blocks\r\n==15215==         suppressed: 0 bytes in 0 blocks\r\n==15215==\r\n==15215== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n```\r\n\r\n## Compatibility\r\n\r\nTested with:\r\n\r\n- Visual Studio 2015+\r\n- Clang 3.4+\r\n- GCC 4.8+\r\n\r\nEvery compiler with full C++11 capability should work.\r\nFunction2 only depends on the standard library.\r\n\r\n## License\r\nFunction2 is licensed under the Boost 1.0 License.\r\n\r\n## Similar implementations\r\n\r\nThere are similar implementations of a function wrapper:\r\n\r\n- [pmed/fixed_size_function](https://github.com/pmed/fixed_size_function)\r\n- [stdex::function](stdex.hpp) - A multi-signature function implementation.\r\n- multifunction - Example from [Boost.TypeErasure](http://www.boost.org/doc/html/boost_typeerasure/examples.html#boost_typeerasure.examples.multifunction), another multi-signature function.\r\n- std::function - [Standard](http://en.cppreference.com/w/cpp/utility/functional/function).\r\n- boost::function - The one from [Boost](http://www.boost.org/doc/libs/1_55_0/doc/html/function.html).\r\n- [func::function](function.h) - From this [blog](http://probablydance.com/2013/01/13/a-faster-implementation-of-stdfunction/).\r\n- [generic::delegate](delegate.hpp) - [Fast delegate in C++11](http://codereview.stackexchange.com/questions/14730/impossibly-fast-delegate-in-c11), also see [here](https://code.google.com/p/cpppractice/source/browse/trunk/).\r\n- [~~ssvu::FastFunc~~](FastFunc.hpp) - Another Don Clugston's FastDelegate, as shown [here](https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/QgvHF7YMi3o).\r\n- [cxx_function::function](https://github.com/potswa/cxx_function) - By David Krauss\r\n\r\nAlso check out the amazing [**CxxFunctionBenchmark**](https://github.com/jamboree/CxxFunctionBenchmark) which compares several implementations.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}